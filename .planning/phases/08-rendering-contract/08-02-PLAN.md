---
phase: 08-rendering-contract
plan: 02
type: execute
---

<objective>
Expose the resolved page data through a custom REST endpoint and Local API helper function.

Purpose: Give Next.js consumers a clean interface to fetch fully-resolved page data.
Output: `/api/pages/:slug/resolved` endpoint, `getResolvedPage` helper, and integration tests.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-rendering-contract/08-01-SUMMARY.md
@dev/collections/Pages.ts
@dev/utils/resolvePageBlocks.ts
@dev/int.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create custom REST endpoint for resolved pages</name>
  <files>dev/endpoints/resolvedPage.ts, dev/payload.config.ts</files>
  <action>
Create endpoint handler in dev/endpoints/resolvedPage.ts:

1. Create `resolvedPageHandler` as PayloadHandler:
   - Extract slug from request path (last segment after /resolved/)
   - Query pages collection with `where: { slug: { equals } }` and `depth: 2`
   - If no page found, return 404 JSON response
   - Call `resolvePageBlocks()` on the found page
   - Return resolved page as JSON with 200 status

2. Register endpoint in payload.config.ts:
   - Add to endpoints array: `{ path: '/pages/:slug/resolved', method: 'get', handler: resolvedPageHandler }`
   - Import handler from './endpoints/resolvedPage.js'

The endpoint URL will be `/api/pages/:slug/resolved` (Payload prefixes with /api).

Handle errors:
- Missing slug parameter - return 400
- Page not found - return 404 with `{ error: 'Page not found' }`
- Internal error - let Payload handle (500)

Do NOT require authentication for this read endpoint.
  </action>
  <verify>pnpm dev starts without errors, endpoint registered in config</verify>
  <done>Custom endpoint created and registered, accessible at /api/pages/:slug/resolved</done>
</task>

<task type="auto">
  <name>Task 2: Create getResolvedPage Local API helper</name>
  <files>dev/utils/getResolvedPage.ts</files>
  <action>
Create a helper function for server-side Local API consumers:

```typescript
import type { Payload } from 'payload'
import type { Page } from '../payload-types'

type ResolvedPage = ReturnType<typeof resolvePageBlocks>

export async function getResolvedPage(
  payload: Payload,
  slug: string
): Promise<ResolvedPage | null>
```

Implementation:
1. Query pages collection: `payload.find({ collection: 'pages', where: { slug: { equals: slug } }, depth: 2 })`
2. If no docs, return null
3. Call resolvePageBlocks on docs[0]
4. Return resolved page

This provides a clean interface for Next.js App Router pages:
```typescript
// In a Next.js page
const page = await getResolvedPage(payload, params.slug)
if (!page) notFound()
```

Import resolvePageBlocks from './resolvePageBlocks'.
  </action>
  <verify>pnpm generate:types && pnpm lint:fix passes</verify>
  <done>getResolvedPage helper created with proper TypeScript types</done>
</task>

<task type="auto">
  <name>Task 3: Add integration tests for endpoint and helper</name>
  <files>dev/int.spec.ts</files>
  <action>
Add to existing "Page block resolution" describe block (or create new "Resolved page API" block):

1. "getResolvedPage returns resolved page by slug"
   - Create ReusableBlock with contentBlock
   - Create Page with reusableBlockRef
   - Call getResolvedPage(payload, slug)
   - Verify returns resolved page with inline contentBlock

2. "getResolvedPage returns null for non-existent slug"
   - Call getResolvedPage(payload, 'does-not-exist')
   - Verify returns null

3. "REST endpoint returns resolved page"
   - Create ReusableBlock and Page with reusableBlockRef
   - Make HTTP GET request to /api/pages/{slug}/resolved
   - Verify 200 status and resolved content

4. "REST endpoint returns 404 for non-existent page"
   - Make HTTP GET request to /api/pages/does-not-exist/resolved
   - Verify 404 status

For HTTP tests, use the test server URL from payload.config (typically http://localhost:3000 in test mode, but check how existing tests handle this - may need to use payload's internal fetch or skip HTTP tests if no test server).

If HTTP testing is complex in current setup, mark tests 3-4 as TODO comments and verify manually.

Import getResolvedPage from '../utils/getResolvedPage'.
  </action>
  <verify>pnpm test:int passes all tests</verify>
  <done>Integration tests pass for Local API helper, endpoint verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm generate:types` succeeds
- [ ] `pnpm lint:fix` passes
- [ ] `pnpm test:int` passes all tests
- [ ] REST endpoint responds correctly at /api/pages/:slug/resolved
- [ ] getResolvedPage helper works for Local API consumers
</verification>

<success_criteria>

- Custom REST endpoint created and registered
- getResolvedPage Local API helper created
- Integration tests pass
- Phase 8 complete - deterministic rendering contract established
</success_criteria>

<output>
After completion, create `.planning/phases/08-rendering-contract/08-02-SUMMARY.md`

Include in summary:
- The rendering contract: "Fetch /api/pages/{slug}/resolved or call getResolvedPage() to get fully-resolved page data"
- All reusableBlockRef blocks are replaced with their actual content
- _resolvedFrom field tracks original ReusableBlock for debugging
</output>
