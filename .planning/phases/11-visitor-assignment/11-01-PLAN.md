---
phase: 11-visitor-assignment
type: execute
---

<objective>
Implement visitor identification and deterministic variant assignment logic.

Purpose: Enable consistent A/B test experiences by assigning visitors to experiment variants based on traffic allocation percentages, with the same visitor always seeing the same variant.
Output: Utilities for visitor ID management, deterministic assignment, and a helper to get the assigned variant for a page/experiment.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./11-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-experiment-collection/10-01-SUMMARY.md
@dev/collections/Experiments.ts
@dev/utils/resolvePageWithVariant.ts
@dev/utils/getResolvedPageWithVariant.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create visitor identification utility</name>
  <files>dev/utils/visitorId.ts</files>
  <action>
Create getOrCreateVisitorId function that:
1. Accepts a cookies object (from Next.js request or similar)
2. Checks for existing 'visitor_id' cookie
3. If exists, returns the value
4. If not, generates new ID using nanoid(21) - 21 chars is standard nanoid length, URL-safe
5. Returns { visitorId: string, isNew: boolean } to let caller know if cookie needs to be set

Also export:
- VISITOR_COOKIE_NAME constant ('visitor_id')
- VISITOR_COOKIE_MAX_AGE constant (365 days in seconds: 31536000)

Do NOT handle cookie setting in this utility - that's the caller's responsibility (different in API routes vs server components). Keep this utility pure and testable.
  </action>
  <verify>Create integration test: generate ID, call again with same ID in mock cookies object, verify same ID returned and isNew=false</verify>
  <done>getOrCreateVisitorId returns consistent visitorId, generates new nanoid when missing, correctly reports isNew status</done>
</task>

<task type="auto">
  <name>Task 2: Create deterministic variant assignment function</name>
  <files>dev/utils/assignVariant.ts</files>
  <action>
Create assignVariantByTraffic function that:
1. Accepts { visitorId: string, experimentId: string, variants: Array<{ variantId: string, trafficPercent: number }> }
2. Creates deterministic hash: concatenate visitorId + experimentId, hash to number 0-99
3. For hashing: use simple string hash (sum of char codes * position, mod 100) - no external crypto needed for A/B bucketing
4. Walk through variants in order, accumulating traffic percentages
5. Return variantId where cumulative traffic >= hash bucket

Example: variants [{id:'A', traffic:50}, {id:'B', traffic:50}]
- Hash 0-49 → variant A
- Hash 50-99 → variant B

Export types:
- VariantAllocation = { variantId: string, trafficPercent: number }
- AssignmentResult = { variantId: string, bucket: number }

Key property: Same visitorId + experimentId ALWAYS returns same variant (deterministic). Different visitors get distributed according to traffic percentages.
  </action>
  <verify>Test determinism: call 100 times with same inputs, verify identical output. Test distribution: generate 1000 random visitorIds, verify ~50/50 split for equal traffic variants</verify>
  <done>assignVariantByTraffic returns consistent variant for same inputs, distributes traffic according to percentages</done>
</task>

<task type="auto">
  <name>Task 3: Create getAssignedVariant helper and integration tests</name>
  <files>dev/utils/getAssignedVariant.ts, dev/int.spec.ts</files>
  <action>
Create getAssignedVariant function that:
1. Accepts { payload: Payload, visitorId: string, pageSlug: string }
2. Finds running experiment for the page (status='running', page relationship matches)
3. If no running experiment, returns null (no experiment active)
4. Maps experiment.variants to VariantAllocation format for assignVariantByTraffic
5. Gets assigned variantId from assignVariantByTraffic
6. Fetches the assigned PageVariant document
7. Uses getResolvedPageWithVariant to get the resolved page with variant applied
8. Returns { resolvedPage, experimentId, variantId, visitorId } or null

Handle edge cases:
- No running experiment → return null
- Multiple running experiments for same page → use first one (log warning)
- Variant not found → throw error (data integrity issue)

Add integration tests (5 tests):
1. Returns null when no running experiment exists
2. Assigns variant deterministically (same visitor always gets same variant)
3. Different visitors get distributed across variants
4. Returns resolved page with variant overrides applied
5. Handles experiment with unequal traffic split (70/30)
  </action>
  <verify>pnpm test:int passes with all new tests</verify>
  <done>getAssignedVariant correctly assigns visitors to variants, returns resolved pages, handles edge cases, 5 integration tests pass</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm lint` passes without errors
- [ ] `pnpm test:int` passes all tests (existing + 5 new)
- [ ] Determinism verified: same visitorId + experimentId always returns same variant
- [ ] Traffic distribution verified: visitors distributed according to percentages
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Visitor assignment is deterministic and consistent
- Traffic allocation respects configured percentages
- Integration tests cover happy path and edge cases
</success_criteria>

<output>
After completion, create `.planning/phases/11-visitor-assignment/11-01-SUMMARY.md`
</output>
