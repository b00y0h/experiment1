---
phase: 17-frontend-renderer-mapping
plan: 01
type: execute
---

<objective>
Implement renderBlock() dispatch function that maps blockType â†’ React component with safe fallbacks and TypeScript exhaustiveness checking.

Purpose: Ensure frontend rendering never crashes on unknown blocks and TypeScript catches missing component mappings at compile time.
Output: `dev/render/renderBlock.tsx` with dispatch function, fallback component, and exhaustive type checking.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@dev/blocks/registry.ts
@dev/payload-types.ts
@dev/block-registry.json

Prior context:
- Phase 16 created blockRegistry with 7 block types: heroBlock, contentBlock, accordionBlock, faqBlock, statsBlock, footerBlock, reusableBlockRef
- Generated payload-types.ts has discriminated unions with blockType field
- resolvePageBlocks.ts handles reusableBlockRef resolution before rendering
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create renderBlock() dispatch function with exhaustive type checking</name>
  <files>dev/render/renderBlock.tsx, dev/render/index.ts</files>
  <action>
Create a new render module:

1. Create `dev/render/renderBlock.tsx`:
   - Import block types from payload-types.ts (use the content array union type)
   - Create BlockComponentMap type mapping blockType slugs to React components
   - Create placeholder components for each block type (simple divs showing blockType + data for now)
   - Create UnknownBlock fallback component that renders block data as JSON with warning styling
   - Implement renderBlock(block: ContentBlock): React.ReactNode that:
     a. Switches on block.blockType
     b. Returns appropriate placeholder component
     c. Uses never type for exhaustiveness (if new blockType added, TypeScript errors)
   - Export renderBlock function and BlockComponentMap type

2. Create `dev/render/index.ts` barrel export

Key patterns:
- Use discriminated union switch pattern: `switch (block.blockType) { case 'heroBlock': ... }`
- Exhaustiveness helper: `const _exhaustive: never = block` in default case
- Placeholder components accept typed props, render structured preview (not just JSON dump)
- UnknownBlock logs warning to console in development

Do NOT import actual UI components (those don't exist yet) - this phase creates the dispatch infrastructure with placeholders that Phase 18 will enforce.
  </action>
  <verify>pnpm build succeeds, TypeScript compiles without errors</verify>
  <done>renderBlock.tsx exists with dispatch function, 7 placeholder components, UnknownBlock fallback, exhaustive type checking compiles</done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for renderBlock dispatch and unknown block handling</name>
  <files>dev/int.spec.ts</files>
  <action>
Add a new test group "renderBlock" to int.spec.ts:

1. Test: "dispatches to correct placeholder for each block type"
   - Create mock block objects for each of the 7 blockTypes
   - Call renderBlock() with each
   - Verify returned element type (use React.isValidElement and check element.type.name or displayName)

2. Test: "returns UnknownBlock for unrecognized blockType"
   - Create a block object with an unknown blockType (cast to bypass TS)
   - Call renderBlock()
   - Verify UnknownBlock component is returned

3. Test: "all registered block types have corresponding renderer"
   - Import getBlockSlugs() from registry
   - For each slug, create a minimal block and verify renderBlock doesn't return UnknownBlock

This ensures the dispatch table stays in sync with the registry.
  </action>
  <verify>pnpm test:int passes all new tests</verify>
  <done>3+ new tests pass, coverage for dispatch, unknown handling, and registry sync</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pnpm build` succeeds without errors
- [ ] `pnpm lint` passes
- [ ] `pnpm test:int` passes all tests including new renderBlock tests
- [ ] TypeScript compiles with no errors (exhaustive check works)
</verification>

<success_criteria>

- renderBlock.tsx exists with working dispatch function
- All 7 block types have placeholder components
- Unknown blocks render safely (no crash)
- TypeScript errors if a new blockType is added without renderer
- Integration tests verify dispatch correctness
- Phase 17 complete
</success_criteria>

<output>
After completion, create `.planning/phases/17-frontend-renderer-mapping/17-01-SUMMARY.md`
</output>
