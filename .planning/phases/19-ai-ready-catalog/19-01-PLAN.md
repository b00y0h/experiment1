---
phase: 19-ai-ready-catalog
plan: 01
type: execute
---

<objective>
Publish "available blocks" catalog endpoint for AI and tooling consumption.

Purpose: AI agents and external tooling need a machine-readable endpoint to discover what blocks exist and their structure, enabling intelligent content generation within valid constraints.
Output: REST endpoint `/api/blocks/catalog` returning the block registry schema JSON.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./19-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/16-block-registry/16-02-SUMMARY.md
@dev/blocks/registry.ts
@dev/blocks/schema.ts
@dev/endpoints/resolvedPage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create block catalog endpoint</name>
  <files>dev/endpoints/blockCatalog.ts, dev/payload.config.ts</files>
  <action>
Create `dev/endpoints/blockCatalog.ts` with a PayloadHandler that:
1. Calls `generateRegistrySchema()` from `../blocks/schema.js`
2. Returns the schema JSON with `Content-Type: application/json`
3. Add cache headers (`Cache-Control: public, max-age=3600`) since registry changes only on deployment

Register endpoint in `dev/payload.config.ts` under `endpoints`:
```ts
{
  path: '/blocks/catalog',
  method: 'get',
  handler: blockCatalogHandler,
}
```

Import handler: `import { blockCatalogHandler } from './endpoints/blockCatalog.js'`

Follow pattern from resolvedPage.ts for handler structure.
  </action>
  <verify>
curl http://localhost:3000/api/blocks/catalog returns JSON with blocks array containing 7 blocks (accordionBlock, contentBlock, faqBlock, footerBlock, heroBlock, reusableBlockRef, statsBlock)
  </verify>
  <done>
- Endpoint returns valid JSON matching RegistrySchema type
- Response includes all 7 registered block types
- Cache headers present
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration test for catalog endpoint</name>
  <files>dev/int.spec.ts</files>
  <action>
Add test suite "Block Catalog Endpoint" with tests:
1. "returns all registered blocks" - GET /api/blocks/catalog, verify response has all 7 blocks
2. "returns valid schema structure" - verify blocks have slug, label, allowedSections, fields
3. "includes field metadata" - spot-check heroBlock has headline field with type=text, required=true

Use existing payload test instance pattern from other endpoint tests.
  </action>
  <verify>pnpm test:int passes with new catalog endpoint tests</verify>
  <done>
- 3 new integration tests for catalog endpoint
- All tests pass
- Coverage for schema structure validation
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm test:int` passes all tests including new catalog tests
- [ ] `pnpm lint` passes
- [ ] `curl localhost:3000/api/blocks/catalog` returns valid JSON with 7 blocks
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- AI and tooling can discover available blocks via REST endpoint
- Schema includes field metadata sufficient for content generation
</success_criteria>

<output>
After completion, create `.planning/phases/19-ai-ready-catalog/19-01-SUMMARY.md`
</output>
