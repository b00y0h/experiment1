---
phase: 16-block-registry
plan: 02
type: execute
---

<objective>
Generate machine-readable registry artifact from Block Registry.

Purpose: Create JSON schema that describes all blocks, their fields, and metadata. This artifact will be consumed by frontend renderer mapping (Phase 17) and AI catalog (Phase 19).

Output: `dev/blocks/schema.ts` with schema generation utilities, `pnpm generate:registry` script, and `dev/block-registry.json` artifact.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
@.planning/phases/16-block-registry/16-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@dev/blocks/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create schema generation utility</name>
  <files>dev/blocks/schema.ts</files>
  <action>
Create `dev/blocks/schema.ts` that exports:

1. `BlockSchemaField` type - describes a field (name, type, required, nested fields for groups/arrays)
2. `BlockSchema` type - describes a block (slug, label, fields, allowedSections)
3. `RegistrySchema` type - array of BlockSchema plus metadata (version, generatedAt)
4. `generateRegistrySchema()` function that:
   - Iterates over blockRegistry from registry.ts
   - Extracts field metadata from each block config
   - Returns RegistrySchema object

Field extraction should capture:
- name, type, required, label
- For groups: nested fields
- For arrays: nested fields
- For selects: options
- For relationships: relationTo
- Skip settings group (internal, not needed for frontend)

The output should be serializable to JSON.
  </action>
  <verify>
- `pnpm lint` passes
- TypeScript compiles without errors
- Calling generateRegistrySchema() returns valid schema for all blocks
  </verify>
  <done>
- `dev/blocks/schema.ts` exports generateRegistrySchema()
- Function returns RegistrySchema with all 7 block types
- Schema includes field metadata for each block
  </done>
</task>

<task type="auto">
  <name>Task 2: Add generate:registry script and emit JSON artifact</name>
  <files>dev/blocks/generate.ts, package.json</files>
  <action>
Create `dev/blocks/generate.ts` script that:
1. Imports generateRegistrySchema from schema.ts
2. Calls it and writes result to `dev/block-registry.json`
3. Logs success message with block count

Add to package.json scripts:
```json
"generate:registry": "tsx dev/blocks/generate.ts"
```

Run the script to generate initial artifact.

The JSON artifact structure:
```json
{
  "version": "1.0.0",
  "generatedAt": "2025-12-31T...",
  "blocks": [
    {
      "slug": "heroBlock",
      "label": "Hero Block",
      "allowedSections": ["hero"],
      "fields": [...]
    },
    ...
  ]
}
```
  </action>
  <verify>
- `pnpm generate:registry` runs successfully
- `dev/block-registry.json` exists and is valid JSON
- JSON contains all 7 block types with their fields
  </verify>
  <done>
- `generate:registry` script added to package.json
- Running script creates `dev/block-registry.json`
- JSON artifact contains complete block metadata
- Phase 16 complete
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm lint` passes
- [ ] `pnpm generate:registry` succeeds
- [ ] `dev/block-registry.json` is valid JSON
- [ ] JSON contains all 7 block types
- [ ] `pnpm test:int` still passes
</verification>

<success_criteria>
- Schema generation utility extracts field metadata from registry
- JSON artifact generated on demand via script
- Artifact is machine-readable for frontend and AI consumption
- Phase 16 complete, ready for Phase 17 (Frontend Renderer Mapping)
</success_criteria>

<output>
After completion, create `.planning/phases/16-block-registry/16-02-SUMMARY.md`
</output>
