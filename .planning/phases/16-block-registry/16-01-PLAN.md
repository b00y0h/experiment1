---
phase: 16-block-registry
plan: 01
type: execute
---

<objective>
Create canonical Block Registry that centralizes all block definitions in one place.

Purpose: Eliminate duplication between Pages.ts and ReusableBlocks.ts. Provide single source of truth for block configurations that can be consumed by collections, frontend renderers, and AI.

Output: `dev/blocks/registry.ts` with all block definitions, updated collections using registry imports.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@dev/collections/Pages.ts
@dev/collections/ReusableBlocks.ts
@dev/fields/blockSettings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Block Registry with all block definitions</name>
  <files>dev/blocks/registry.ts, dev/blocks/index.ts</files>
  <action>
Create `dev/blocks/registry.ts` that exports:
1. Individual block configs (heroBlock, contentBlock, accordionBlock, faqBlock, statsBlock, footerBlock, reusableBlockRef)
2. Section-grouped exports (heroBlocks, contentBlocks, footerBlocks)
3. A `blockRegistry` object mapping blockType slug to block config

Each block config should:
- Be a factory function returning Payload Block type (to support createBlockSettings() which must be called fresh)
- Include full field definitions currently in Pages.ts
- Use restrictedLexicalEditor for richText fields

Also create `dev/blocks/index.ts` barrel file re-exporting from registry.

DO NOT modify Pages.ts or ReusableBlocks.ts yet - that's Task 2.
  </action>
  <verify>
- `pnpm lint` passes on new files
- New files export all block types (heroBlock, contentBlock, accordionBlock, faqBlock, statsBlock, footerBlock, reusableBlockRef)
  </verify>
  <done>
- `dev/blocks/registry.ts` exists with all block factory functions
- `dev/blocks/index.ts` exists as barrel export
- Block definitions match current inline definitions exactly
  </done>
</task>

<task type="auto">
  <name>Task 2: Update collections to use Block Registry</name>
  <files>dev/collections/Pages.ts, dev/collections/ReusableBlocks.ts</files>
  <action>
Update both collections to import blocks from `dev/blocks/registry`:

For Pages.ts:
- Remove inline block definitions from hero, content, footer arrays
- Import block factories from '../blocks'
- Call factories in blocks arrays: `blocks: [heroBlock()]`
- Keep restrictedLexicalEditor definition (used by registry)
- Keep hooks (ensureBlockIds, validateConversionElement)
- Keep all other collection config unchanged

For ReusableBlocks.ts:
- Remove inline block definitions from block array
- Import block factories from '../blocks'
- Call factories: `blocks: [accordionBlock(), contentBlock(), footerBlock(), faqBlock(), statsBlock()]`
- Keep hooks (ensureBlockIds)
- Keep blockType select field as-is

IMPORTANT: Move restrictedLexicalEditor to registry.ts since blocks need it. Export it for collections that may need it.
  </action>
  <verify>
- `pnpm lint` passes
- `pnpm generate:types` succeeds (types unchanged)
- `pnpm test:int` passes (all 76 tests)
  </verify>
  <done>
- Pages.ts imports blocks from registry
- ReusableBlocks.ts imports blocks from registry
- No inline block definitions remain in collections
- All integration tests pass
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm lint` passes
- [ ] `pnpm generate:types` succeeds
- [ ] `pnpm test:int` passes (76 tests)
- [ ] Block definitions are identical (compare generated types before/after)
</verification>

<success_criteria>
- All block definitions centralized in dev/blocks/registry.ts
- Pages.ts and ReusableBlocks.ts use registry imports
- No functional changes - types and tests unchanged
- Clean separation: registry owns definitions, collections compose them
</success_criteria>

<output>
After completion, create `.planning/phases/16-block-registry/16-01-SUMMARY.md`
</output>
