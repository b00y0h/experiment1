---
phase: 07-validation-guardrails
plan: 01
type: execute
---

<objective>
Add field-level validation constraints to prevent garbage data from being created.

Purpose: Ensure all block content meets quality standards with meaningful admin error messages.
Output: Validated fields with max lengths, required rules, and array limits across Pages and ReusableBlocks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@dev/collections/Pages.ts
@dev/collections/ReusableBlocks.ts
@dev/fields/blockSettings.ts
@dev/int.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared field validators</name>
  <files>dev/validators/fieldValidators.ts</files>
  <action>
Create a validators module with reusable field validation functions:

1. `maxLengthValidator(max: number)` - Returns Payload validate function for text fields
2. `urlValidator` - Validates URL format (optional field, validates if present)
3. `ctaValidator` - Custom validator ensuring if ctaText is set, ctaLink must also be set (and vice versa)

Pattern for Payload validate functions:
```ts
validate: (value, { data, siblingData }) => {
  if (condition) return 'Error message'
  return true
}
```

Export all validators for use in collection configs. Use TypeScript strict typing.
  </action>
  <verify>pnpm lint passes, file exists with exported validators</verify>
  <done>Three validators exported: maxLengthValidator, urlValidator, ctaValidator</done>
</task>

<task type="auto">
  <name>Task 2: Apply field constraints to Pages collection</name>
  <files>dev/collections/Pages.ts</files>
  <action>
Import validators and apply constraints:

1. heroBlock.headline: Add `maxLength: 100` and custom validate using maxLengthValidator(100)
2. heroBlock.cta.ctaText: Add `maxLength: 50`
3. heroBlock.cta.ctaLink: Add urlValidator
4. heroBlock.cta (group): Add custom validate ensuring both ctaText and ctaLink are set together or neither
5. accordionBlock.items: Add `maxRows: 20` to prevent excessive items
6. faqBlock.items: Add `maxRows: 30` to prevent excessive items
7. statsBlock.items: Add `maxRows: 12` to prevent excessive items

For the CTA group validation, use a beforeValidate field hook on the cta group that checks siblingData.
  </action>
  <verify>pnpm lint passes, pnpm test:int passes</verify>
  <done>Field constraints applied, existing tests still pass</done>
</task>

<task type="auto">
  <name>Task 3: Add validation integration tests</name>
  <files>dev/int.spec.ts</files>
  <action>
Add a new describe block 'Field validation' with tests:

1. Test headline max length - create page with 101+ char headline, expect rejection
2. Test CTA completeness - create page with ctaText but no ctaLink, expect rejection
3. Test CTA URL format - create page with invalid URL in ctaLink, expect rejection
4. Test valid CTA passes - create page with both ctaText and ctaLink properly set
5. Test accordion max items - attempt to create with 21 items, expect rejection (or verify maxRows prevents it)

Tests should verify meaningful error messages are returned (not generic failures).
  </action>
  <verify>pnpm test:int passes with new tests</verify>
  <done>5+ validation tests passing, covering field constraints</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pnpm lint` passes
- [ ] `pnpm test:int` passes (all existing + new validation tests)
- [ ] Creating page with >100 char headline fails with clear error
- [ ] Creating page with incomplete CTA fails with clear error
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Field validators are reusable across collections
- Validation errors are meaningful (not generic)
- Ready for 07-02-PLAN.md (page-level validation)
</success_criteria>

<output>
After completion, create `.planning/phases/07-validation-guardrails/07-01-SUMMARY.md`
</output>
